h1. Intro to CSS 3D Transforms

Ladies and gentlemen, it is the second decade of the second millenium and we are still kicking around the same 2D interface we got three decades ago. Sure, Apple debuted OSX 10.7 apps that added a couple more 3D flourishes, and Microsoft has had that "Flip 3D":http://windows.microsoft.com/en-US/windows-vista/Using-Windows-Flip-3D for a while. But c'mon, 2011 is in a couple weeks. Where is our 3D virtual reality? By now, we should be zipping around the "Metaverse in super-sonic motorbikes":http://en.wikipedia.org/wiki/Snow_Crash.

While the capability of rendering complex 3D environments has been present for years, current digital interfaces predominately exist in a two dimensional environment. Largely this is due to the constraints of the physical equipment themselves. The monitor has width and height. The mouse moves left, right, up, down. Our users' interfaces are ill-equipped to interact with the three spatial dimensions. After decades of development, even the biggest and best native software developers have only managed to dip their flattened toes in a pool of width, height, and _depth._  

h2. Rationale

While 3D transforms might be sexy and cool, we owe it to our users to ask what can they benefit from them. The entire application does not have to take advantage of 3D. There is plenty of opportunity to use 3D transforms _in between_ the interface, via transitions. Take for instance the Weather App on the iPhone. The application uses two views, a details view of the weather and an options panel for selecting locations. Switching between these two views is done with a 3D flip transition. This affords the user that interface has but two views, and only two views, as the exist on two sides of the same plane.

!img/weather-app-transition.jpg(Weather App transition)!

Consider image cycle interfaces. What cues tip-off the user that the advancing from the last slide will re-start the cycle at the first? A better paradigm can be used with a 3D transform, where the slides are places side by side one another _in a circle out in 3D space_. In that arrangement, the last slide logically does come before the first.

Not only can we use 3D transforms to create more visually impressive applications, but we can also use them to solve dilemmas. 

h2. Current Support Environment

The third dimension isn't limited to just CSS. We could dive into the capabilities of 3D in Flash, canvas, "three.js":http://github.com/mrdoob/three.js/, or WebGL. But as far as this article is concerned, I'll be focusing solely on CSS 3D transforms.

"The CSS3 spec for 3D transforms":http://www.w3.org/TR/css3-3d-transforms/ has been out in the wild a year now, but currrently, they are only supported by Safari (which includes Safari on the desktop and Mobile Safari on iOS devices). Support on other browsers varies. 

The Mozilla team has "made some initial steps":https://bugzilla.mozilla.org/show_bug.cgi?id=505115 towards implementing CSS 3D transforms. "Mike Taylor":twitter.com/miketaylr tells me the Opera team is keeping a close eye on CSS transforms, and is waiting until the spec is fleshed out. And our best friend Internet Explorer still needs to catch up to 2D transforms before we can talk about 3D.

To make matters more perplexing, WebKit-cousin Chrome currently accepts 3D transform declarations, but renders them in 2D space. Per Chrome team member "Paul Irish":http://twitter.com/paul_irish, 3D transforms are on the horizon, perhaps in one of the next X.0 releases. 

This all adds up to a bit of a challenge for those of us ready for 3D transforms. I'll give it to you straight, missing that dimension of depth will make degradation especially un-graceful. Unless the transform is relatively simple and holds up in non-3D-supporting browsers, you'll most likely have to design another solution if you're ready to take on 3D transforms.

Here's the part of the article where I mention "Modernizr":http://modernizr.com, and you brush over it because you've read this part of an article hundreds of times before. But seriously, it's the best way to test for CSS 3D transform support. Use it.

Even with these hurdles in place, trying out 3D transforms now is a good move. The CSS 3D transforms spec was developed by the same team at Apple who produced the "CSS 2D transforms":http://www.w3.org/TR/css3-2d-transforms/ and "animation":http://www.w3.org/TR/css3-animations/ specifications.  Both of these specifications have been adopted by Mozilla and Opera. Transforming three-dimensionally now will guarantee you'll be ahead of the game when the other browsers catch up.

The choice is yours. You can make excuses and poo-poo 3D transforms, or (with a "tip of the fedora to Mr. Andy Clarke":http://hardboiledwebdesign.com/) you can get hard-boiled and start designing with the best features out there.

h2. Perspective

To activate 3D space, an element needs perspective.  This can be applied in two ways: using the @transform@ property, with the perspective as a functional notation.

bc. -webkit-transform: perspective(800);

or using the @perspective@ property: 

bc. -webkit-perspective: 800;

"*See Example 12.*":12-perspective.html

These two formats produce the same effect, but there is a difference. The functional notation method is fairly convenient for directly applying a 3D transform on a single element (in Example 12, I am using it with a rotateX transform). The problem is that it doesn't work for multiple elements, since the perspective is only for the one element. If you use the same transform across elements with different position, each element will have its own vanishing point. To remedy this, use the @perspective@ property on a parent element, so each child exists in the same 3D space.

"*See Example 14.*":14-child-perspective.html

The value of perspective determines the intensity of the 3D effect. Think of it as a distance. @perspective: 2000;@ yeilds a subtle 3D effect, as if you are viewing an object from far away through binoculars. @perspective: 100;@ produces an tremendous 3D effect, as if you are a tiny insect viewing a massive object up close.

By default, the vanishing point for a 3D space is positioned at the center. You can change the position of the vanishing point with @perspetive-origin@ property.

bc. -webkit-perspective-origin: 25% 75%

"*See Example 5.*":05-perspective.html



h2. 3D transform functions

As a web designer, you'll probably well-acquainted with working in 2 dimensions, X and Y, for positioning items horizontally and vertically. 3D transforms enable you to position elements in the third Z dimension, which positions elements nearer and further in 3D space. 

With a 3D space initialized with @perspective@, you can now transform elements in all 3 glorious dimensions. 3D transforms use the same @transform@ property used for 2D transforms. If you're already familiar with 2D transforms, you'll find the basic "3D transform functions":http://www.w3.org/TR/css3-3d-transforms/#transform-functions fairly similar. 

* @rotateX( angle )@ 
* @rotateY( angle )@
* @rotateZ( angle )@
* @translateZ( tz )@
* @scale( sz )@

Whereas @translateX()@ positions an element along the horizontal X axis, @translateZ()@ positions it along the Z axis, which runs front to back in 3D space. Positive values position the element closer to the viewer, negative values further away.

The rotate functions will rotate the element around the corresponding axis. Using @rotateX( 45deg )@ will rotate around the horizontal X axis, so the top of the element will be angled back, and the bottom will be angled closer.

"*See Example 15.*":15-basic-transforms.html

Looking at this demo, note that no matter how small the perspective value is, or where ever the transform origin may be, the 1 panel always returns to its original position, as if all those funky 3D transforms didn't even matter. 

There's also several shorthand transform functions that require values for all three dimensions:

* @translate3d( tx, ty, tz )@
* @scale3d( sx, sy, sz )@
* @rotate3d( rx, ry, rz, angle )@

I'm skipping over @matrix3d()@, as this function is especially complex and requires comprehension of "transformation matrix.":http://www.w3.org/TR/SVG/coords.html#TransformMatrixDefined As I understand it, the function was developed for robots, by robots.

*Pro-tip:* These @foo3d()@ transform functions also have the benefit of triggering hardware acceleration in Safari. Dean Jackson, CSS 3D transform spec author and main WebKit dude, writes (by way of "Thomas Fuchs":http://mir.aculo.us/2010/08/05/html5-buzzwords-in-action/):

bq. In essence, any transform that has a 3D operation as one of its functions will trigger hardware compositing, even when the actual transform is 2D, or not doing anything at all (such as translate3d(0,0,0)). Note this is just current behaviour, and could change in the future (which is why we donâ€™t document or encourage it). But it is very helpful in some situations and can significantly improve redraw performance.

For the sake of simplicity, these demos will use the basic transform functions, but if you're writing production-ready CSS for iOS or Safari-only, *make sure to use the @foo3d()@ functions to get the best rendering performance.*

h2. Card flip

We now have all the tools to start making 3D objects. Let's get started with the basics, flipping a card. %%As mentioned above discussing the iPhone Weather app, using a card interface --do we need rationale here?--%%%

Here's the basic markup we'll need:

bc. <section class="container">
  <div class="card">
    <figure class="front">1</figure>
    <figure class="back">2</figure>
  </div>
</section>

So what do we have here. Obviously we need the faces of the card, both @front@ and @back@. The @card@ acts as a wrapper for the faces of the object. Finally the @container@ will house the 3D space. We're ready for some 3D stylez. Even for such a simple object, I recommend using this same patern for any 3D transform.  Keeping the 3D space element and the object element establishes a paradigm that is simple to understand and easier to style.

First, apply necessary @perspective@ to the parent 3D space, along with any size or positioning styles.

bc. .container { 
  width: 200px;
  height: 260px;
  -webkit-perspective: 800;
}

Now the @#card@ element can be transformed in 3D space, since its parent has @perspective@.  Let's add a CSS3 transition so users can see the transform take effect.

bc. #card {
  width: 100%;
  height: 100%;
  -webkit-transform-style: preserve-3d;
  -webkit-transition: -webkit-transform 1s;
}

As this is a 3D transform, this element ought to exist in 3D space. The @.container@'s @perspective@ only applies to direct descendant children, in this case @#card@. In order for children to inherit a parent's perspective, and live in the same 3D space, the parent needs to have @transform-style: preserve-3d@. Without 3D @transform-style@, these faces would be flattened with its parents and the back face's rotation would be nullified. 

With the transition in place, we need a corresponding style for the @#card@ for when it is flipped.

bc. #card.flipped {
  -webkit-transform: rotateY( 180deg );
}

To position the faces in 3D space, we'll need to reset their positions in 2D with @position: absolute@. In order to hide the back-side of the faces when they are faced away from the viewer, we use @backface-visibility: hidden@. 

bc. #card figure {
  display: block;
  position: absolute;
  width: 100%;
  height: 100%;
  -webkit-backface-visibility: hidden;
}

To flip the back around, we add a basic 3D transform of @rotateY( 180deg )@. 

bc. #card .front {
  background: red;
}
#card .back {
  background: blue;
  -webkit-transform: rotateY( 180deg );
}

Now we have a working 3D object. To flip the card, we can toggle the @flipped@ class. When @flipped@, the @#card@ will rotate 180 degress, thus exposing the @.back@ face.

"*See Example 16.*":16-card.html

h2. Slide flip

Take another look at the Weather App 3D transition. You'll notice that it's not quite the same effect as the one produced in the previous demo. If you follow the right edge of the card, you'll find that it stays flush with the container. Instead of pivoting from the horizontal center, it pivots on that right edge. But the transition is not just a rotation. The edge moves from right to left. We can reproduce this transform with our original card flip demo, just by modifying a couple lines of CSS.

The pivot point for the rotation occurs at the right side of the card. By default, the @transform-origin@ of an element is at its horizontal and vertical center (@50% 50%@ or @center center@). Let's change it to the right side:

bc. #card { -webkit-transform-origin: right center; }

That flip now needs some horizontal movement with @translateX@. We'll also set the rotation to @-180deg@ to it flips right side out.

bc. #card.flipped {
  -webkit-transform: translateX( -100% ) rotateY( -180deg );
}

"*See Example 17*":17-slide-flip.html and "*Example 18*":18-slide-flip.html.

h2. 3D objects

3D cards are a nice easy step into working with 3D dimensions. But once you've mastered them, you'll be hungry to push it further and create some true 3D objects: prisms. We'll get started by making a cube.

The markup for the cube is similar to the cube. This time we need 6 child elements for all 6 faces of the cube.

bc. <section class="container">
  <div class="box">
    <figure class="front">1</figure>
    <figure class="back">2</figure>
    <figure class="right">3</figure>
    <figure class="left">4</figure>
    <figure class="top">5</figure>
    <figure class="bottom">6</figure>
  </div>
</section>

Basic position and size styles set the 6 faces flat, right on top of one another in the container.

bc. .container {
  width: 200px;
  height: 200px;
  -webkit-perspective: 1000;
}
#cube {
  width: 100%;
  height: 100%;
  -webkit-transform-style: preserve-3d;
}
#cube figure {
  width: 196px;
  height: 196px;
  display: block;
  position: absolute;
  border: 2px solid black;
}

With the card, we only had to rotate the back side, the cube, however, requires that 5 of the 6 faces need to be rotated. Faces 1 and 2 will be the front and back. Faces 3 and 4 will be the sides. Faces 5 and 6 will be the top and bottom.

bc. #cube .front  { -webkit-transform: rotateY(   0deg ); }
#cube .back   { -webkit-transform: rotateX( 180deg ); }
#cube .right  { -webkit-transform: rotateY(  90deg ); }
#cube .left   { -webkit-transform: rotateY( -90deg ); }
#cube .top    { -webkit-transform: rotateX(  90deg ); }
#cube .bottom { -webkit-transform: rotateX( -90deg ); }

We could leave out the @#cube .front@ style declaration, as the transform has no effect, but let's leave it in to keep our code consistent.

Now each face is rotated, and only the front face is visible. The 4 side faces are all perpendicular to the viewer, so they appear invisible. To push them out to their appropriate sides, they need to be translated out from the center of their positions. Each side of the cube is 200px wide. As the faces are in the center, they'll need to be translated out half that distance, 100px.

bc. #cube .front  { -webkit-transform: rotateY(   0deg ) translateZ( 100px ); }
#cube .back   { -webkit-transform: rotateX( 180deg ) translateZ( 100px ); }
#cube .right  { -webkit-transform: rotateY(  90deg ) translateZ( 100px ); }
#cube .left   { -webkit-transform: rotateY( -90deg ) translateZ( 100px ); }
#cube .top    { -webkit-transform: rotateX(  90deg ) translateZ( 100px ); }
#cube .bottom { -webkit-transform: rotateX( -90deg ) translateZ( 100px ); }

Note here that the @translateZ@ function comes _after_ the @rotate@. Take a moment and soak this in. Each face is first rotated towards its position, then translated out to that position.

Now we have a 3D object. Neat! But we're not done yet.

Once we start pushing elements out of the Z origin plane, all sorts of fun things happen to its appearance. In order to keep 3D transforms snappy, Safari composites the element then applies the transform. Consequently, anti-aliasing on text will remain whatever it was without the transform. When transformed forward in 3D space, serious pixelation can occur.

"*See Example 8*":08-pixelation.html

To resolve this issue and restore pixel perfection, we can push back the box, so that the front face will be positioned back at the Z origin.

bc. .box { -webkit-transform: translateZ( -100px ); }

"*See Example 20*":20-cube-steps.html

To expose any face of the cube, we'll need a style that rotates the cube to expose any face. As the object is a cube, the transform is the opposite of the transform of the corresponding face. We toggle the necessary class on the @#box@ to apply the appropriate transform.

bc. #box.show-front  { -webkit-transform: translateZ( -100px ) rotateY(    0deg ); }
#box.show-back   { -webkit-transform: translateZ( -100px ) rotateX( -180deg ); }
#box.show-right  { -webkit-transform: translateZ( -100px ) rotateY(  -90deg ); }
#box.show-left   { -webkit-transform: translateZ( -100px ) rotateY(   90deg ); }
#box.show-top    { -webkit-transform: translateZ( -100px ) rotateX(  -90deg ); }
#box.show-bottom { -webkit-transform: translateZ( -100px ) rotateX(   90deg ); }

"*See Example 1*":01-cube.html


h3. Boxes and prisms

Cube objects are easy enough to generate as we only have to worry about one measurement. But how would we handle a non-regular rectangular prism? Let's try to make one 300px wide, 200px high, and 100px deep. The markup remains the same as the previous version. The container styles remain mostly the same.

bc. .container {
  width: 300px;
  height: 200px;
  -webkit-perspective: 1000;
}
#box {
  width: 100%;
  height: 100%;
  -webkit-transform-style: preserve-3d;
}

Each set of faces will need their own sizes.

bc. #box figure {
  display: block;
  position: absolute;
  border: 2px solid black;
}
/* front and back */
#box .front,
#box .back {
  width: 296px;
  height: 196px;
}
/* left and right sides */
#box .right,
#box .left {
  width: 96px;
  height: 196px;
  left: 100px;
}
/* top and bottom */
#box .top,
#box .bottom {
  width: 296px;
  height: 96px;
  top: 50px;
}

The smaller faces (left, right, top and bottom) need to be positioned in the center of the container, where they can be easily rotated and then shifted outward. The thinner left and right faces get positioned @left: 100px@, The stouter top and bottom faces get positioned @top: 50px@.

The rotate values all can remain the same, but for this rectangular prism, the translate values do differ. The front and back faces each are shifted out @50px@ since the box is 100px deep. Left and right faces translate is @150px@ for 300px width. Top and bottom panels go @100px@ for the 200px height.

bc. #box .front  { -webkit-transform: rotateY(   0deg ) translateZ(  50px ); }
#box .back   { -webkit-transform: rotateX( 180deg ) translateZ(  50px ); }
#box .right  { -webkit-transform: rotateY(  90deg ) translateZ( 150px ); }
#box .left   { -webkit-transform: rotateY( -90deg ) translateZ( 150px ); }
#box .top    { -webkit-transform: rotateX(  90deg ) translateZ( 100px ); }
#box .bottom { -webkit-transform: rotateX( -90deg ) translateZ( 100px ); }

Again, to expose a face, the box needs to have a style to reverse its transform.

bc. #box.show-front  { -webkit-transform: translateZ(  -50px ) rotateY(    0deg ); }
#box.show-back   { -webkit-transform: translateZ(  -50px ) rotateX( -180deg ); }
#box.show-right  { -webkit-transform: translateZ( -150px ) rotateY(  -90deg ); }
#box.show-left   { -webkit-transform: translateZ( -150px ) rotateY(   90deg ); }
#box.show-top    { -webkit-transform: translateZ( -100px ) rotateX(  -90deg ); }
#box.show-bottom { -webkit-transform: translateZ( -100px ) rotateX(   90deg ); }


h3. Carousel

Front-end developers have a myriad of choices when it comes to content carousels. Now that we have 3D capabilities in our browsers, why not give a shot at creating an actual 3D carousel?

The mark-up for this demo uses the same format as the boxes and card.

bc. <div class="container">
  <div id="carousel">
    <figure>1</figure>
    <figure>2</figure>
    <figure>3</figure>
    <figure>4</figure>
    <figure>5</figure>
    <figure>6</figure>
    <figure>7</figure>
    <figure>8</figure>
    <figure>9</figure>
  </div>
</div>

Apply basic styles. For this demo, I'm giving each panel of the carousel 20px gaps between one another.  But the effective width of each panel remains 210px.

bc. .container {
  width: 210px;
  height: 140px;
  -webkit-perspective: 1000;
}
#carousel {
  width: 100%;
  height: 100%;
  -webkit-transform-style: preserve-3d;
}
#carousel figure {
  display: block;
  position: absolute;
  width: 186px;
  height: 116px;
  left: 10px;
  top: 10px;
  border: 2px solid black;
}

Next up: rotating the faces. This carousel has 9 panels. If each panel gets an equal distribution on the carousel, each panel would be rotated 40 degrees from the next ( 360 / 9 ).

bc. #carousel figure:nth-child(1) { -webkit-transform: rotateY(   0deg ); }
#carousel figure:nth-child(2) { -webkit-transform: rotateY(  40deg ); }
#carousel figure:nth-child(3) { -webkit-transform: rotateY(  80deg ); }
#carousel figure:nth-child(4) { -webkit-transform: rotateY( 120deg ); }
#carousel figure:nth-child(5) { -webkit-transform: rotateY( 160deg ); }
#carousel figure:nth-child(6) { -webkit-transform: rotateY( 200deg ); }
#carousel figure:nth-child(7) { -webkit-transform: rotateY( 240deg ); }
#carousel figure:nth-child(8) { -webkit-transform: rotateY( 280deg ); }
#carousel figure:nth-child(9) { -webkit-transform: rotateY( 320deg ); }

Now the outward shift. Back when we were creating cube and boxes, the value was simple to calculate, as it was equal to one half the width, height, or depth of the object. Now with a carousel, there is no predefined size of the object. We'll have calculate the distance for the shift by other means.

Drawing out a diagram of the carousel, we see that we only know two things: the width of each panel is 210px and the each panel is rotated 40 degrees from the next. If we split one of these triangles down its center, we get a right triangle, prime for some trigonometry.

!img/diagram.png(Geometric diagram of carousel)!

We can determine the length of _r_ in this diagram with a basic tangent equation.

!img/calc.png(Trigonometric calculation)!

There you have it, 288px is the distance to translate the panels out in 3D space.

bc. #carousel figure:nth-child(1) { -webkit-transform: rotateY(   0deg ) translateZ( 288px ); }
#carousel figure:nth-child(2) { -webkit-transform: rotateY(  40deg ) translateZ( 288px ); }
#carousel figure:nth-child(3) { -webkit-transform: rotateY(  80deg ) translateZ( 288px ); }
#carousel figure:nth-child(4) { -webkit-transform: rotateY( 120deg ) translateZ( 288px ); }
#carousel figure:nth-child(5) { -webkit-transform: rotateY( 160deg ) translateZ( 288px ); }
#carousel figure:nth-child(6) { -webkit-transform: rotateY( 200deg ) translateZ( 288px ); }
#carousel figure:nth-child(7) { -webkit-transform: rotateY( 240deg ) translateZ( 288px ); }
#carousel figure:nth-child(8) { -webkit-transform: rotateY( 280deg ) translateZ( 288px ); }
#carousel figure:nth-child(9) { -webkit-transform: rotateY( 320deg ) translateZ( 288px ); }

Just like our previous 3D objects, to show any one panel, we need only to apply the reverse transform on the carousel. to show the fifth panel:

bc. -webkit-transform: translateZ( -288px ) rotateY( -160deg );

"*See Example 22*":22-carousel.html

By now, you probably are thinking two thoughts: 

# Re-writing transform styles for each panel looks to be tedious. 
# Why bother doing high school math -- Aren't robots supposed to be doing all this work for us?  

And you're absolutely right. The repetitive nature of 3D objects lend themselves to scripting. We can offload all the tedious transform styles to our dynamic script, which, if done right, will be more flexible than the hard-coded version.

"*See Example 7*":07-apple-carousel-gallery.html

h2. Further Discussion

Pardon the obvious pun, 3D transforms open up a world a possibilities for interface designers. It changes the whole way you think about the canvas.  Actually, it changes the flat canvas itself into a room. As we start employing more 3D transforms, a whole new crop of challenges will emerge. Here's a couple questions to get us started:

* The @transform@ style property houses all the transforms. What's the best way to get and set the values inside this one property?
* What's the best way to resolve for browsers that don't support 3D transforms?
* How can we avoid crushing browser performance while still achieving these awesome transforms?



h3. About the author

If the Web were a coloring book, David DeSandro would be the kid manically scribbling outside the lines of every page, whittling away his crayons of front-end development to wee nubs. Lucky for him, he's paid to do the thing he loves, creating engaging, innovative interfaces at "nclud":http://nclud.com. Come nightfall, he dons a cape, develops "fun-time articles":http://desandro.com and "resources":http://github.com/desandro, journals his "findings":http://dropshado.ws, and fights crime around Washington, DC.

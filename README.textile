h1. Intro to CSS 3D Transforms

Ladies and gentlemen, it is the second decade of the second millennium and we are still kicking around the same 2D interface we got three decades ago. Sure, Apple debuted a few apps for OSX 10.7 that have a couple more 3D flourishes, and Microsoft has had that "Flip 3D":http://windows.microsoft.com/en-US/windows-vista/Using-Windows-Flip-3D for a while. But c'mon, 2011 is right around the corner. That's _Twenty Eleven_ folks. Where is our 3D virtual reality? By now, we should be zipping around the "Metaverse in super-sonic motorbikes":http://en.wikipedia.org/wiki/Snow_Crash.

Granted, the capability of rendering complex 3D environments has been present for years. On the Web, there already are number of solutions -- "Flash":http://www.adobe.com/devnet/flash/3d_animation.html, "three.js":https://github.com/mrdoob/three.js/ in canvas, and eventually WebGL. And finally, we meager front-end developers have our own three-dimensional jewel: CSS 3D Transforms!

h2. Rationale

Like a beautiful jewel, 3D transform can be dazzling, a true spectacle to behold. But before we start tacking 3D diamonds and rubies to our compositions like Liberace's tailor, we owe it to our users to ask what can they benefit from this awesome feature. 

The entire application does not, and should not, take advantage of 3D. CSS was built to style documents, not generate explorable environments. I fail to find a benefit to filling out a web form that can be accessed by swiveling my viewport to the Sign-Up Room (although there have been proposals to make the Web just that). However, there is plenty of opportunity to use 3D transforms _in between_ the interface, via transitions.

Take for instance the Weather App on the iPhone. The application uses two views: a details view and an options view. Switching between these two views is done with a 3D flip transition. This affords the user that the interface has two and only two views, as they can only exist on either side of the same plane.

!img/weather-app-transition.jpg(iPhone Weather App 3D flip transition)!

Also consider slide cycle plugins. When you're at the last slide, what cues tip-off the user that the advancing will re-start the cycle at the first? A better paradigm can be used with a 3D transform, where the slides are placed side by side one another in a circle in 3D space. In that arrangement, the last slide logically comes before the first.

3D transforms are more than just eye candy. We can also use them to solve dilemmas and make our applications more intuitive. 

h2. Current Support Environment

"The CSS 3D transforms module ":http://www.w3.org/TR/css3-3d-transforms/ has been out in the wild for over a year now. Currently, only Safari supports the specification -- which includes Safari on OSX and Mobile Safari on iOS. 

The support roadmap on other browsers varies. The Mozilla team has "made some initial steps":https://bugzilla.mozilla.org/show_bug.cgi?id=505115 towards implementing the module. "Mike Taylor":http://twitter.com/miketaylr tells me the Opera team is keeping a close eye on CSS transforms, and is waiting until the specification is fleshed out. And our best friend Internet Explorer still needs to catch up to 2D transforms before we can talk about the 3D variety.

To make matters more perplexing, Safari's WebKit-cousin Chrome currently accepts 3D transform declarations, but renders them in 2D space. Per Chrome team member "Paul Irish":http://twitter.com/paul_irish, 3D transforms are on the horizon, perhaps in one of the next X.0 releases. 

This all adds up to a bit of a challenge for those of us excited for 3D transforms. I'll give it to you straight: missing that dimension of depth can make degradation a bit ungraceful. Unless the transform is relatively simple and holds up in non-3D-supporting browsers, you'll most likely have to design another solution. But what's another hurdle in a steeplechase? We web folk have had our mettle tested for years. We're galvanized for devising multiple solutions.

Here's the part of the article where I mention "Modernizr":http://modernizr.com, and you brush over it because you've read this part of an article a hundreds of times before. But seriously, it's the best way to test for CSS 3D transform support. Use it.

Even with these difficulties mounted up, trying out 3D transforms today is the right move. The CSS 3D transforms module was developed by the same team at Apple who produced the "CSS 2D transforms":http://www.w3.org/TR/css3-2d-transforms/ and "animation":http://www.w3.org/TR/css3-animations/ modules.  Both specifications have since been adopted by Mozilla and Opera. Transforming three-dimensionally now will guarantee you'll be ahead of the game when the other browsers catch up.

The choice is yours. You can make excuses and poo-poo 3D transforms because they're too hard and only snobby Apple fans will see them today. Or, with a "tip of the fedora to Mr. Andy Clarke":http://hardboiledwebdesign.com/, you can get hardboiled and start designing with the best features out there right this instant.

So I bid you, "in the words of the eternal Optimus Prime":http://tfwiki.net/wiki/Roll_out...

bq. Transform and roll out.

Let's get coding.

h2. Perspective

To activate 3D space, an element needs perspective.  This can be applied in two ways: using the @transform@ property, with the perspective as a functional notation.

bc. -webkit-transform: perspective( 600 );

or using the @perspective@ property: 

bc. -webkit-perspective: 600;

"*See Example: Perspective 1.*":http://desandro.github.com/3dtransforms/examples/perspective-01.html

"!img/perspective01.png(Perspective property at work)!":http://desandro.github.com/3dtransforms/examples/perspective-01.html

These two formats both trigger a 3D space, but there is a difference. The functional notation is convenient for directly applying a 3D transform on a single element (in "the previous example":http://desandro.github.com/3dtransforms/examples/perspective-01.html, I use it in conjunction with a @rotateX@ transform). But when used on multiple elements, the transformed elements don't line up as expected. If you use the same transform across elements with different positions, each element will have its own vanishing point. To remedy this, use the @perspective@ property on a parent element, so each child may share the same 3D space.

"*See Example: Perspective 2.*":http://desandro.github.com/3dtransforms/examples/perspective-02-children.html

"!img/perspective-children01.png(Perspective differences when used with child elements)!":http://desandro.github.com/3dtransforms/examples/perspective-02-children.html

The value of @perspective@ determines the intensity of the 3D effect. Think of it as a distance from the viewer to the object. The greater the value, the further the distance, the less intense the visual effect. @perspective: 2000;@ yields a subtle 3D effect, as if we are viewing an object from far away through binoculars. @perspective: 100;@ produces a tremendous 3D effect, like a tiny insect viewing a massive object.

By default, the vanishing point for a 3D space is positioned at the center. You can change the position of the vanishing point with @perspective-origin@ property.

bc. -webkit-perspective-origin: 25% 75%;

"*See Example: Perspective 3.*":http://desandro.github.com/3dtransforms/examples/perspective-03.html

"!img/perspective02.png(Intense perspective value, with vanishing point modified)!":http://desandro.github.com/3dtransforms/examples/perspective-03.html

h2. 3D transform functions

As a web designer, you're probably well acquainted with working in two dimensions, X and Y, positioning items horizontally and vertically. With a 3D space initialized with @perspective@, we can now transform elements in all three glorious spatial dimensions, including the third Z dimension. 

3D transforms use the same @transform@ property used for 2D transforms. If you're familiar with 2D transforms, you'll find the basic "3D transform functions":http://www.w3.org/TR/css3-3d-transforms/#transform-functions fairly similar. 

* @rotateX( angle )@ 
* @rotateY( angle )@
* @rotateZ( angle )@
* @translateZ( tz )@
* @scaleZ( sz )@

Whereas @translateX()@ positions an element along the horizontal X axis, @translateZ()@ positions it along the Z axis, which runs front to back in 3D space. Positive values position the element closer to the viewer, negative values further away.

The @rotate@ functions rotate the element around the corresponding axis. This is a bit counter-intuitive at first as you might imagine that @rotateX@ will spin an object left to right. Instead, using @rotateX( 45deg )@ rotates an element _around_ the horizontal X axis, so the top of the element angles back and away, and the bottom angles near.

"*See Example: Transforms 1.*":http://desandro.github.com/3dtransforms/examples/transforms-01-functions.html

"!img/transforms01.png(CSS 3D transform functions)!":http://desandro.github.com/3dtransforms/examples/transforms-01-functions.html

There's also several shorthand transform functions that require values for all three dimensions:

* @translate3d( tx, ty, tz )@
* @scale3d( sx, sy, sz )@
* @rotate3d( rx, ry, rz, angle )@

*Pro-tip:* These @foo3d()@ transform functions also have the benefit of triggering hardware acceleration in Safari. Dean Jackson, CSS 3D transform spec author and main WebKit dude, writes (by way of "Thomas Fuchs":http://mir.aculo.us/2010/08/05/html5-buzzwords-in-action/):

bq. In essence, any transform that has a 3D operation as one of its functions will trigger hardware compositing, even when the actual transform is 2D, or not doing anything at all (such as @translate3d(0,0,0)@). Note this is just current behaviour, and could change in the future (which is why we don't document or encourage it). But it is very helpful in some situations and can significantly improve redraw performance.

For the sake of simplicity, these demos will use the basic transform functions, but if you're writing production-ready CSS for iOS or Safari-only, *make sure to use the @foo3d()@ functions to get the best rendering performance.*

h2. Card flip

We now have all the tools to start making 3D objects. Let's get started with the basics, flipping a card.

Here's the basic markup we'll need:

bc. <section class="container">
  <div id="card">
    <figure class="front">1</figure>
    <figure class="back">2</figure>
  </div>
</section>

The @.container@ will house the 3D space. The @#card@ acts as a wrapper for the 3D object. Two separate elements for both faces of the card, @.front@ and @.back@. Even for such a simple object, I recommend using this same pattern for any 3D transform.  Keeping the 3D space element and the object separate element establishes a paradigm that is simple to understand and easier to style.

We're ready for some 3D stylin'. First, apply necessary @perspective@ to the parent 3D space, along with any size or positioning styles.

bc. .container { 
  width: 200px;
  height: 260px;
  position: relative;
  -webkit-perspective: 800;
}

Now the @#card@ element can be transformed in its parent's 3D space. We're using absolute/relative positioning so the 3D object is removed from the flow of the document. We'll also add @width: 100%;@  and @height: 100%;@. This ensures the object's @transform-origin@ will occur in the center of container. More on @transform-origin@ later. 

Let's add a CSS3 transition so users can see the transform take effect. 

bc. #card {
  width: 100%;
  height: 100%;
  position: absolute;
  -webkit-transform-style: preserve-3d;
  -webkit-transition: -webkit-transform 1s;
}

The @.container@'s @perspective@ only applies to direct descendant children, in this case @#card@. In order for subsequent children to inherit a parent's perspective, and live in the same 3D space, the parent can pass along its perspective with @transform-style: preserve-3d@. Without 3D @transform-style@, the faces of the card would be flattened with its parents and the back face's rotation would be nullified. 

To position the faces in 3D space, we'll need to reset their positions in 2D with @position: absolute@. In order to hide the back-side of the faces when they are faced away from the viewer, we use @backface-visibility: hidden@. 

bc. #card figure {
  display: block;
  position: absolute;
  width: 100%;
  height: 100%;
  -webkit-backface-visibility: hidden;
}

To flip the @.back@ face, we add a basic 3D transform of @rotateY( 180deg )@. 

bc. #card .front {
  background: red;
}
#card .back {
  background: blue;
  -webkit-transform: rotateY( 180deg );
}

With the faces in place, the @#card@ requires a corresponding style for when it is flipped.

bc. #card.flipped {
  -webkit-transform: rotateY( 180deg );
}

Now we have a working 3D object. To flip the card, we can toggle the @flipped@ class. When @.flipped@, the @#card@ will rotate 180 degrees, thus exposing the @.back@ face.

"*See Example: Card 1.*":http://desandro.github.com/3dtransforms/examples/card-01.html

"!img/card-flip01.png(3D card flip transition)!":http://desandro.github.com/3dtransforms/examples/card-01.html

h2. Slide-flip

Take another look at the Weather App 3D transition. You'll notice that it's not quite the same effect as "our previous demo":http://desandro.github.com/3dtransforms/examples/card-01.html. If you follow the right edge of the card, you'll find that it stays flush with the container. Instead of pivoting from the horizontal center, it pivots on that right edge. But the transition is not just a rotation -- the edge moves horizontally from right to left. We can reproduce this transition just by modifying a couple lines of CSS from our original card flip demo.

The pivot point for the rotation occurs at the right side of the card. By default, the @transform-origin@ of an element is at its horizontal and vertical center (@50% 50%@ or @center center@). Let's change it to the right side:

bc. #card { -webkit-transform-origin: right center; }

That flip now needs some horizontal movement with @translateX@. We'll set the rotation to @-180deg@ so it flips right side out.

bc. #card.flipped {
  -webkit-transform: translateX( -100% ) rotateY( -180deg );
}

"*See Example: Card 2*":http://desandro.github.com/3dtransforms/examples/card-02-slide-flip.html.

"!img/card-flip02.png(3D card slide-flip transition)!":http://desandro.github.com/3dtransforms/examples/card-02-slide-flip.html

h2. Cube

Creating 3D card objects is a good way to get started with 3D transform. But once you've mastered them, you'll be hungry to push it further and create some true 3D objects: prisms. We'll start out by making a cube.

The markup for the cube is similar to the card. This time we need 6 child elements for all 6 faces of the cube.

bc. <section class="container">
  <div id="cube">
    <figure class="front">1</figure>
    <figure class="back">2</figure>
    <figure class="right">3</figure>
    <figure class="left">4</figure>
    <figure class="top">5</figure>
    <figure class="bottom">6</figure>
  </div>
</section>

Basic position and size styles set the 6 faces on top of one another in the container.

bc. .container {
  width: 200px;
  height: 200px;
  position: relative;
  -webkit-perspective: 1000;
}
#cube {
  width: 100%;
  height: 100%;
  position: absolute;
  -webkit-transform-style: preserve-3d;
}
#cube figure {
  width: 196px;
  height: 196px;
  display: block;
  position: absolute;
  border: 2px solid black;
}

With the card, we only had to rotate its back face. The cube, however, requires that 5 of the 6 faces to be rotated. Faces 1 and 2 will be the front and back. Faces 3 and 4 will be the sides. Faces 5 and 6 will be the top and bottom.

bc. #cube .front  { -webkit-transform: rotateY(   0deg ); }
#cube .back   { -webkit-transform: rotateX( 180deg ); }
#cube .right  { -webkit-transform: rotateY(  90deg ); }
#cube .left   { -webkit-transform: rotateY( -90deg ); }
#cube .top    { -webkit-transform: rotateX(  90deg ); }
#cube .bottom { -webkit-transform: rotateX( -90deg ); }

We could remove the @#cube .front@ style declaration, as this transform has no effect, but let's leave it in to keep our code consistent.

Now each face is rotated, and only the front face is visible. The 4 side faces are all perpendicular to the viewer, so they appear invisible. To push them out to their appropriate sides, they need to be translated out from the center of their positions. Each side of the cube is 200px wide. From the cube's center they'll need to be translated out half that distance, @100px@.

bc. #cube .front  { -webkit-transform: rotateY(   0deg ) translateZ( 100px ); }
#cube .back   { -webkit-transform: rotateX( 180deg ) translateZ( 100px ); }
#cube .right  { -webkit-transform: rotateY(  90deg ) translateZ( 100px ); }
#cube .left   { -webkit-transform: rotateY( -90deg ) translateZ( 100px ); }
#cube .top    { -webkit-transform: rotateX(  90deg ) translateZ( 100px ); }
#cube .bottom { -webkit-transform: rotateX( -90deg ) translateZ( 100px ); }

Note here that the @translateZ@ function comes _after_ the @rotate@. The order of transform functions is important. Take a moment and soak this in. Each face is first rotated towards its position, then translated outward in a separate vector.

We have a working cube, but we're not done yet.

h3. Returning to the Z origin plane

For the sake of our users, our 3D transforms should not distort the interface when the active panel is at its resting position. But once we start pushing elements out of the Z origin plane, distortion is inevitable. 

In order to keep 3D transforms snappy, Safari composites the element then applies the transform. Consequently, anti-aliasing on text will remain whatever it was before the transform was applied. When transformed forward in 3D space, significant pixelation can occur. 

"*See Example: Transforms 2*":http://desandro.github.com/3dtransforms/examples/transforms-02-pixelation.html.

"!img/pixelation01.png(Using 3D transforms can pixelate text)!":http://desandro.github.com/3dtransforms/examples/transforms-02-pixelation.html

Looking at back at the "Perspective 3 demo":http://desandro.github.com/3dtransforms/examples/perspective-03.html, note that no matter how small the perspective value is, or where ever the transform origin may be, the 1 panel always returns to its original position, as if all those funky 3D transforms didn't even matter.

To resolve the distortion and restore pixel perfection on our @#cube@, we can push back the 3D object, so that the front face will be positioned back at the Z origin.

bc. #cube { -webkit-transform: translateZ( -100px ); }

"*See Example: Cube 1*":http://desandro.github.com/3dtransforms/examples/cube-01-steps.html.

"!img/cube01.png(CSS 3D cube object)!":http://desandro.github.com/3dtransforms/examples/cube-01-steps.html

To expose any face of the cube, we'll need a style that rotates the cube to expose any face. The transform is the opposite of the corresponding face. We toggle the necessary class on the @#box@ to apply the appropriate transform.

bc. #cube.show-front  { -webkit-transform: translateZ( -100px ) rotateY(    0deg ); }
#cube.show-back   { -webkit-transform: translateZ( -100px ) rotateX( -180deg ); }
#cube.show-right  { -webkit-transform: translateZ( -100px ) rotateY(  -90deg ); }
#cube.show-left   { -webkit-transform: translateZ( -100px ) rotateY(   90deg ); }
#cube.show-top    { -webkit-transform: translateZ( -100px ) rotateX(  -90deg ); }
#cube.show-bottom { -webkit-transform: translateZ( -100px ) rotateX(   90deg ); }

Notice how the order of the transform functions has reversed. First we push the object back with @translateZ@, then we rotate it.

Finishing up, we can add a transition to animate the rotation between states. 

bc. #cube {  -webkit-transition: -webkit-transform 1s; }

"*See Example: Cube 2*":http://desandro.github.com/3dtransforms/examples/cube-02-show-sides.html.

"!img/cube02.png(CSS 3D cube object changing sides)!":http://desandro.github.com/3dtransforms/examples/cube-02-show-sides.html

h2. Rectangular Prism

Cube objects are easy enough to generate as we only have to worry about one measurement. But how would we handle a non-regular rectangular prism? Let's try to make one 300px wide, 200px high, and 100px deep. 

The markup remains the same as the @#cube@'s version, but switch the @#cube@ id for @#box@. The container styles remain mostly the same.

bc. .container {
  width: 300px;
  height: 200px;
  position: relative;
  -webkit-perspective: 1000;
}
#box {
  width: 100%;
  height: 100%;
  position: absolute;
  -webkit-transform-style: preserve-3d;
}

Now, to position the faces. Each set of faces will need their own sizes. The smaller faces (left, right, top and bottom) need to be positioned in the center of the container, where they can be easily rotated and then shifted outward. The thinner left and right faces get positioned @left: 100px@ ( (300 - 100) / 2 ), The stouter top and bottom faces get positioned @top: 50px@ ( (200 - 100) / 2 ).

bc. #box figure {
  display: block;
  position: absolute;
  border: 2px solid black;
}
#box .front,
#box .back {
  width: 296px;
  height: 196px;
}
#box .right,
#box .left {
  width: 96px;
  height: 196px;
  left: 100px;
}
#box .top,
#box .bottom {
  width: 296px;
  height: 96px;
  top: 50px;
}

The rotate values all can remain the same as in the cube example, but for this rectangular prism, the translate values do differ. The front and back faces each are shifted out @50px@ since the @#box@ is 100px deep. Left and right faces translate is @150px@ for 300px width. Top and bottom panels go @100px@ for the 200px height.

bc. #box .front  { -webkit-transform: rotateY(   0deg ) translateZ(  50px ); }
#box .back   { -webkit-transform: rotateX( 180deg ) translateZ(  50px ); }
#box .right  { -webkit-transform: rotateY(  90deg ) translateZ( 150px ); }
#box .left   { -webkit-transform: rotateY( -90deg ) translateZ( 150px ); }
#box .top    { -webkit-transform: rotateX(  90deg ) translateZ( 100px ); }
#box .bottom { -webkit-transform: rotateX( -90deg ) translateZ( 100px ); }

"*See Example: Box 1*":http://desandro.github.com/3dtransforms/examples/box-01-steps.html.

"!img/box01.png(3D CSS box object)!":http://desandro.github.com/3dtransforms/examples/box-01-steps.html

Just like the cube example, to expose a face, the @#box@ needs to have a style to reverse its face's transform. Both the @translateZ@ and @rotate@ values are the opposites of the corresponding face.

bc. #box.show-front  { -webkit-transform: translateZ(  -50px ) rotateY(    0deg ); }
#box.show-back   { -webkit-transform: translateZ(  -50px ) rotateX( -180deg ); }
#box.show-right  { -webkit-transform: translateZ( -150px ) rotateY(  -90deg ); }
#box.show-left   { -webkit-transform: translateZ( -150px ) rotateY(   90deg ); }
#box.show-top    { -webkit-transform: translateZ( -100px ) rotateX(  -90deg ); }
#box.show-bottom { -webkit-transform: translateZ( -100px ) rotateX(   90deg ); }

"*See Example: Box 2*":http://desandro.github.com/3dtransforms/examples/box-02-show-sides.html.

"!img/box02.png(3D CSS box object rotating)!":http://desandro.github.com/3dtransforms/examples/box-02-show-sides.html

h2. Carousel

Front-end developers have a myriad of choices when it comes to content carousels. Now that we have 3D capabilities in our browsers, why not give a shot at creating an actual 3D carousel?

The markup for this demo takes the same form as the box, cube, and card. Let's make it interesting and have a carousel with 9 panels.

bc. <div class="container">
  <div id="carousel">
    <figure>1</figure>
    <figure>2</figure>
    <figure>3</figure>
    <figure>4</figure>
    <figure>5</figure>
    <figure>6</figure>
    <figure>7</figure>
    <figure>8</figure>
    <figure>9</figure>
  </div>
</div>

Now apply basic layout styles. Let's give each panel of the @#carousel@ 20px gaps between one another, done here with @left: 10px;@ and @top: 10px;@. The effective width of each panel remains 210px.

bc. .container {
  width: 210px;
  height: 140px;
  position: relative;
  -webkit-perspective: 1000;
}
#carousel {
  width: 100%;
  height: 100%;
  position: absolute;
  -webkit-transform-style: preserve-3d;
}
#carousel figure {
  display: block;
  position: absolute;
  width: 186px;
  height: 116px;
  left: 10px;
  top: 10px;
  border: 2px solid black;
}

Next up: rotating the faces. This @#carousel@ has 9 panels. If each panel gets an equal distribution on the carousel, each panel would be rotated 40 degrees from the next ( 360 / 9 ).

bc. #carousel figure:nth-child(1) { -webkit-transform: rotateY(   0deg ); }
#carousel figure:nth-child(2) { -webkit-transform: rotateY(  40deg ); }
#carousel figure:nth-child(3) { -webkit-transform: rotateY(  80deg ); }
#carousel figure:nth-child(4) { -webkit-transform: rotateY( 120deg ); }
#carousel figure:nth-child(5) { -webkit-transform: rotateY( 160deg ); }
#carousel figure:nth-child(6) { -webkit-transform: rotateY( 200deg ); }
#carousel figure:nth-child(7) { -webkit-transform: rotateY( 240deg ); }
#carousel figure:nth-child(8) { -webkit-transform: rotateY( 280deg ); }
#carousel figure:nth-child(9) { -webkit-transform: rotateY( 320deg ); }

Now the outward shift. Back when we were creating cube and boxes, the @translate@ value was simple to calculate, as it was equal to one half the width, height, or depth of the object. Now with a carousel, there is no size we can immediately reference. We'll have calculate the distance for the shift by other means.

Drawing out a diagram of the carousel, we see that we only know two things: the width of each panel is 210px and the each panel is rotated 40 degrees from the next. If we split one of these triangles down its center, we get a right triangle, prime for some trigonometry.

!img/diagram.png(Geometric diagram of carousel)!

We can determine the length of _r_ in this diagram with a basic tangent equation.

!img/calc.png(Trigonometric calculation)!

There you have it, @288px@ is the distance to translate the panels out in 3D space. 

bc. #carousel figure:nth-child(1) { -webkit-transform: rotateY(   0deg ) translateZ( 288px ); }
#carousel figure:nth-child(2) { -webkit-transform: rotateY(  40deg ) translateZ( 288px ); }
#carousel figure:nth-child(3) { -webkit-transform: rotateY(  80deg ) translateZ( 288px ); }
#carousel figure:nth-child(4) { -webkit-transform: rotateY( 120deg ) translateZ( 288px ); }
#carousel figure:nth-child(5) { -webkit-transform: rotateY( 160deg ) translateZ( 288px ); }
#carousel figure:nth-child(6) { -webkit-transform: rotateY( 200deg ) translateZ( 288px ); }
#carousel figure:nth-child(7) { -webkit-transform: rotateY( 240deg ) translateZ( 288px ); }
#carousel figure:nth-child(8) { -webkit-transform: rotateY( 280deg ) translateZ( 288px ); }
#carousel figure:nth-child(9) { -webkit-transform: rotateY( 320deg ) translateZ( 288px ); }


If we decide on changing the width of the panel or the number of panels, we only need to plug in those two variables into our equation to get the appropriate translateZ value. In JS terms, that equation would be:

bc. var tz = Math.round( ( panelSize / 2 ) / 
  Math.tan( ( ( Math.PI * 2 ) / numberOfPanels ) / 2 ) );
// or simplified to
var tz = Math.round( ( panelSize / 2 ) / 
  Math.tan( Math.PI / numberOfPanels ) );

Just like our previous 3D objects, to show any one panel, we need only to apply the reverse transform on the carousel. Here's the style to show the fifth panel:

bc. -webkit-transform: translateZ( -288px ) rotateY( -160deg );

"*See Example: Carousel 1*":http://desandro.github.com/3dtransforms/examples/carousel-01.html.

"!img/carousel01.png(3D CSS carousel)!":http://desandro.github.com/3dtransforms/examples/carousel-01.html

By now, you probably have two thoughts: 

# Re-writing transform styles for each panel looks to be tedious. 
# Why bother doing high school math -- Aren't robots supposed to be doing all this work for us?  

And you're absolutely right. The repetitive nature of 3D objects lend themselves to scripting. We can offload all the monotonous transform styles to our dynamic script, which, if done right, will be more flexible than the hard-coded version.

"*See Example: Carousel 2*":http://desandro.github.com/3dtransforms/examples/carousel-02-dynamic.html.

h2. Conclusion

3D transforms change the way we think about the blank canvas of web design. Better yet, they change canvas itself, trading in the flat surface for an voluminous installation.

My hope is that you took at least one peak a demo and were intrigued. We web designers, who have rejoiced for border-radius, box-shadow, and background gradient, now have an incredible tool at our disposal in 3D transforms. They deserve just the same enthusiasm, research, and experimentation we have spent on the previous browser features. Now is the perfect time to figuratively take the plunge and start thinking about how leveraging three dimensions can elevate our craft. I'm enthralled to witness what's to come. 

See you on the flip side.

h3. About the author

If the Web were a coloring book, "*David DeSandro*":http://desandro.com would be the kid manically scribbling outside the lines of every page, whittling away his front-end development crayons to wee nubs. Lucky for him, he's paid to do the thing he loves, creating engaging, innovative interfaces at "nclud":http://nclud.com. Come nightfall, he dons a cape, develops "resources":http://github.com/desandro, journals his "discoveries":http://dropshado.ws, and fights crime around Washington DC.

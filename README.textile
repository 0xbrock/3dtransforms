h2. Intro

Ladies in gentlemen, it is the second decade of the second millenium and we are still kicking around the same 2D interface we got two decades ago in the original Mac. Sure, Apple debuted some 10.7 apps that added a couple more 3D flourishes, and Microsoft has had that "Flip 3D":http://windows.microsoft.com/en-US/windows-vista/Using-Windows-Flip-3D for a while. But c'mon, 2011 is in a couple weeks. We should be zipping around the Metaverse in super-sonic motorbikes , as Hiro Protagonist did in Neal Stephenson's _Snow Crash._ 

While the capability of rendering complex 3D environments has been present for years, the digital interfaces of today predominately exist in a two dimensional environment. Largely this is due to the constraints of the physical interfaces themselves. The monitor has width and height. The mouse moves left, right, up, down. Digital interfaces are ill equipped to interact with in three dimensions. After decades of development, even the biggest and best native software developers have only managed to dip their flattened toes in a pool of width, height, and _depth._  

h2. Rationale

While 3D transforms might be sexy and cool, we owe it to our users to ask what can they benefit from them. Take the "Snow Stack":http://www.satine.org/archives/2009/07/11/snow-stack-is-here/ demo. While visually engaging, I don't see any inherent utility of a completely 3D interface. The users interface is 2D. CSS was developed for 2D documents. Creating 3D environments, while it may be achievable, just doesn't make sense for our users.

The entire application does not have to take advantage of 3D, but there is plenty of opportunity to use 3D transforms _in between_ the interface, via transitions. Take for instance the Weather App on the iPhone. The application uses two views, a details view of the weather, and a editable view of options for selecting locations. Switching between these two views is done with a 3D flip transition. This affords the user that interface has but two views, and only two views, as the exist on two sides of the same plane.

Also consider image cycle interfaces. What cues tip-off the user that the advancing from the last slide will re-start the cycle at the first? A better paradigm can be used with a 3D transform, where the slides are places side by side one another _in a circle in the third dimension_. In that arrangement, the last slide logically does come before the first.

Not only can we use 3D transforms to create more visually impressive applications, but we can also use them to solve dilemmas. 

h2. Current Support Environment

"The CSS3 spec for 3D transforms":http://www.w3.org/TR/css3-3d-transforms/ has been public for over a year now, but at the moment of writing this article, they are only supported by Safari, which includes Safari on the desktop and Mobile Safari on iOS devices. Support on other browsers varies. WebKit-cousin Chrome  currently accepts 3D transform declarations, but renders them in 2D space. Per Chrome team member Paul Irish, 3D transforms are on the roadmap, perhaps in the next couple X.0 releases. The Mozilla team has "made some initial steps":https://bugzilla.mozilla.org/show_bug.cgi?id=505115 towards implementing CSS 3D transforms. Per Mike Taylor, the Opera team is keeping a close eye on CSS transforms, and is waiting until the spec is fleshed out. And our best friend Internet Explorer still needs to catch up to 2D transforms before we can talk about 3D.

With such limited support why bother at all? To begin with, the CSS 3D transforms spec was developed by the same team at Apple who produced the "CSS 2d transforms":http://www.w3.org/TR/css3-2d-transforms/ and "animation":http://www.w3.org/TR/css3-animations/ specifications.  Both of these specifications have been adopted by Mozilla and Opera. I'm willing to wager that the 3D spec will follow in suit.

Of course, the third dimension isn't limited to just CSS. We could dive into the cabilities of 3D in Flash, canvas, three.js, or WebGL. But for the sake of brevity, I'll be limiting the scope of article to solely CSS 3D transforms.

Given the sparse support for 3D transforms, you can choose to ignore them, or (with a "tip of the fedora to Mr. Andy Clarke":http://hardboiledwebdesign.com/ ) you can get hard-boiled and start designing with the best features out there.

h2. Getting Started



h3. Perspective

To activate 3D space, an element needs perspective.  This can be applied in two ways: using the @transform@ property, with the perspective as a functional notation.

bc. -webkit-transform: perspective(800);

or using the @perspective@ property: 

bc. -webkit-perspective: 800;

"*See Example 12.*":12-perspective.html

These two formats produce the same effect, but there is a difference. The functional notation method is fairly convenient for directly applying a 3D transform on a single element (in Example 12, I am using it with a rotateX transform). The problem is that it doesn't work for multiple elements, since the perspective is only for the one element. If you use the same transform across elements with different position, each element will have its own vanishing point. To remedy this, use the @perspective@ property on a parent element, so each child exists in the same 3D space.

"*See Example 14.*":14-child-perspective.html

Direct descendants of 3D parents will inherit their parents perspective. But grand-children and future generations (if you will) will be flattened with the direct children. In order to pass on perspective, the children in-between the element with perspective, and the element being 3d-transformed need to have @-webkit-transform-style: preserve-3d@.

%% needs example? %%

The value of perspective determines the intensity of the 3D effect. Think of it as a distance. @perspective: 2000;@ yeilds a subtle 3D effect, as if you are viewing an object from far away through binoculars. @perspective: 100;@ produces an tremendous 3D effect, as if you are a tiny insect viewing a massive object up close.

By default, the vanishing point for a 3D space is positioned at the center. You can change the position of the vanishing point with @perspetive-origin@ property.

bc. -webkit-perspective-origin: 25% 75%

"*See Example 5.*":05-perspective.html



h3. 3D transform functions

As a web designer, you'll probably well-acquainted with working in 2 dimensions, X and Y, for positioning items horizontally and vertically. 3D transforms enable you to position elements in the third Z dimension, which positions elements nearer and farther in 3D space. 

With a 3D space initialized, you can now get cracking transforming elements in all 3 glorious dimensions. 3D transforms use the same @transform@ property used for 2D transforms. If you're already familiar with 2D transforms, you'll find the basic "3D transform functions":http://www.w3.org/TR/css3-3d-transforms/#transform-functions fairly similar. Whereas @translateX()@ positions an element along the horizontal X axis, @translateX()@ positions it along the Z axis, which runs front to back in 3D space. Positive values position the element closer to the viewer, negative values further away.

The rotate functions will rotate the element around the corresponding axis. Using @rotateX( 45deg )@ will rotate around the horizontal X axis, so the top of the element will be angled back, and the bottom will be angled closer.

"*See Example 15.*":15-basic-transforms.html


There's also several shorthand transform functions that require values for all three dimensions:

* @translate3d( _tx_, _ty_, _tz_ )@
* @scale3d( _sx_, _sy_, _sz_ )@
* @rotate3d( _rx_, _ry_, _rz_, _angle_ )@

I'm skipping over @matrix3d()@, as this function is especially complex and requires comprehension of "transformation matrix.":http://www.w3.org/TR/SVG/coords.html#TransformMatrixDefined As I understand it, it's for robots, by robots. I've yet to wrap my head around it and haven't run into a scenario where I needed to (knock on wood).


For the sake of brevity, 

These @foo3d()@ transform functions also have the benefit of triggering hardware acceleration in Safari.  Dean Jackson, CSS 3D transform spec author and main WebKit dude, writes (by way of "Thomas Fuchs":http://mir.aculo.us/2010/08/05/html5-buzzwords-in-action/):

bq. In essence, any transform that has a 3D operation as one of its functions will trigger hardware compositing, even when the actual transform is 2D, or not doing anything at all (such as translate3d(0,0,0)). Note this is just current behaviour, and could change in the future (which is why we donâ€™t document or encourage it). But it is very helpful in some situations and can significantly improve redraw performance.



`backface-visibility`

`transforming for returning to 0 on the z axis`

`perspective inheritance`

`transform-origin`

`transition end events`





Looking at this %demo%, note that no matter how small the perspective value is, or where ever the transform origin is, the 1 panel always returns to its original position, as if it were not a part of a rotating 3D cube. 


h3. About the author

If the Web were a coloring book, David DeSandro would be the kid manically scribbling outside the lines of every page, whittling away his favorite crayons, HTML, CSS, and JavaScript, to wee nubs. By day, he creates engaging, dynamic interfaces at "nclud.":http://nclud.com By night, he makes "unique interactive articles":http://desandro.com, develops "sweet front-end dev resources":http://github.com/desandro, journals his "explorations in the uncharted waters of web design":http://dropshado.ws, and fights crime around Washington, DC.

h2. Intro

Ladies and gentlemen, it is the second decade of the second millenium and we are still kicking around the same 2D interface we got two decades ago. Sure, Apple debuted some 10.7 apps that added a couple more 3D flourishes, and Microsoft has had that "Flip 3D":http://windows.microsoft.com/en-US/windows-vista/Using-Windows-Flip-3D for a while. But c'mon, 2011 is in a couple weeks. We should be zipping around the "Metaverse in super-sonic motorbikes":http://en.wikipedia.org/wiki/Snow_Crash.

While the capability of rendering complex 3D environments has been present for years, the digital interfaces of today predominately exist in a two dimensional environment. Largely this is due to the constraints of the physical interfaces themselves. The monitor has width and height. The mouse moves left, right, up, down. Digital interfaces are ill-equipped to interact with the three spatial dimensions. After decades of development, even the biggest and best native software developers have only managed to dip their flattened toes in a pool of width, height, and _depth._  

h2. Rationale

While 3D transforms might be sexy and cool, we owe it to our users to ask what can they benefit from them. Take the "Snow Stack":http://www.satine.org/archives/2009/07/11/snow-stack-is-here/ demo. Granted the experience is visually engaging, I don't see any inherent utility of a completely 3D interface. The users interface is 2D. CSS was developed for 2D documents. Creating 3D environments, while it may be achievable, just doesn't make sense for our users.

The entire application does not have to take advantage of 3D, but there is plenty of opportunity to use 3D transforms _in between_ the interface, via transitions. Take for instance the Weather App on the iPhone. The application uses two views, a details view of the weather, and a editable view of options for selecting locations. Switching between these two views is done with a 3D flip transition. This affords the user that interface has but two views, and only two views, as the exist on two sides of the same plane.

Also consider image cycle interfaces. What cues tip-off the user that the advancing from the last slide will re-start the cycle at the first? A better paradigm can be used with a 3D transform, where the slides are places side by side one another _in a circle in the third dimension_. In that arrangement, the last slide logically does come before the first.

Not only can we use 3D transforms to create more visually impressive applications, but we can also use them to solve dilemmas. 

h2. Current Support Environment

"The CSS3 spec for 3D transforms":http://www.w3.org/TR/css3-3d-transforms/ has been public for over a year now, but at the moment of writing this article, they are only supported by Safari, which includes Safari on the desktop and Mobile Safari on iOS devices. Support on other browsers varies. WebKit-cousin Chrome  currently accepts 3D transform declarations, but renders them in 2D space. Per Chrome team member Paul Irish, 3D transforms are on the roadmap, perhaps in the next couple X.0 releases. The Mozilla team has "made some initial steps":https://bugzilla.mozilla.org/show_bug.cgi?id=505115 towards implementing CSS 3D transforms. Per Mike Taylor, the Opera team is keeping a close eye on CSS transforms, and is waiting until the spec is fleshed out. And our best friend Internet Explorer still needs to catch up to 2D transforms before we can talk about 3D.

With such limited support why bother at all? To begin with, the CSS 3D transforms spec was developed by the same team at Apple who produced the "CSS 2d transforms":http://www.w3.org/TR/css3-2d-transforms/ and "animation":http://www.w3.org/TR/css3-animations/ specifications.  Both of these specifications have been adopted by Mozilla and Opera. I'm willing to wager that the 3D spec will follow in suit.

Of course, the third dimension isn't limited to just CSS. We could dive into the capabilities of 3D in Flash, canvas, three.js, or WebGL. But for the sake of brevity, I'll be limiting the scope of article to solely CSS 3D transforms.

%% using Modernizr. need to create 2 solutions %%

Given the sparse support for 3D transforms, you can choose to ignore them, or (with a "tip of the fedora to Mr. Andy Clarke":http://hardboiledwebdesign.com/ ) you can get hard-boiled and start designing with the best features out there.

h2. Perspective

To activate 3D space, an element needs perspective.  This can be applied in two ways: using the @transform@ property, with the perspective as a functional notation.

bc. -webkit-transform: perspective(800);

or using the @perspective@ property: 

bc. -webkit-perspective: 800;

"*See Example 12.*":12-perspective.html

These two formats produce the same effect, but there is a difference. The functional notation method is fairly convenient for directly applying a 3D transform on a single element (in Example 12, I am using it with a rotateX transform). The problem is that it doesn't work for multiple elements, since the perspective is only for the one element. If you use the same transform across elements with different position, each element will have its own vanishing point. To remedy this, use the @perspective@ property on a parent element, so each child exists in the same 3D space.

"*See Example 14.*":14-child-perspective.html

Direct descendants of 3D parents will inherit their parents perspective. But grand-children and future generations (if you will) will be flattened with the direct children. In order to pass on perspective, the children in-between the element with perspective, and the element being 3d-transformed need to have @-webkit-transform-style: preserve-3d@.

%% needs example? %%

The value of perspective determines the intensity of the 3D effect. Think of it as a distance. @perspective: 2000;@ yeilds a subtle 3D effect, as if you are viewing an object from far away through binoculars. @perspective: 100;@ produces an tremendous 3D effect, as if you are a tiny insect viewing a massive object up close.

By default, the vanishing point for a 3D space is positioned at the center. You can change the position of the vanishing point with @perspetive-origin@ property.

bc. -webkit-perspective-origin: 25% 75%

"*See Example 5.*":05-perspective.html



h2. 3D transform functions

As a web designer, you'll probably well-acquainted with working in 2 dimensions, X and Y, for positioning items horizontally and vertically. 3D transforms enable you to position elements in the third Z dimension, which positions elements nearer and further in 3D space. 

With a 3D space initialized with @perspective@, you can now transform elements in all 3 glorious dimensions. 3D transforms use the same @transform@ property used for 2D transforms. If you're already familiar with 2D transforms, you'll find the basic "3D transform functions":http://www.w3.org/TR/css3-3d-transforms/#transform-functions fairly similar. 

* @rotateX( _angle_ )@ 
* @rotateY( _angle_ )@
* @rotateZ( _angle_ )@
* @translateZ( _tz_ )@

Whereas @translateX()@ positions an element along the horizontal X axis, @translateZ()@ positions it along the Z axis, which runs front to back in 3D space. Positive values position the element closer to the viewer, negative values further away.

The rotate functions will rotate the element around the corresponding axis. Using @rotateX( 45deg )@ will rotate around the horizontal X axis, so the top of the element will be angled back, and the bottom will be angled closer.

"*See Example 15.*":15-basic-transforms.html


There's also several shorthand transform functions that require values for all three dimensions:

* @translate3d( _tx_, _ty_, _tz_ )@
* @scale3d( _sx_, _sy_, _sz_ )@
* @rotate3d( _rx_, _ry_, _rz_, _angle_ )@

I'm skipping over @matrix3d()@, as this function is especially complex and requires comprehension of "transformation matrix.":http://www.w3.org/TR/SVG/coords.html#TransformMatrixDefined As I understand it, the function developed for robots, by robots.

*Pro-tip:* These @_foo_3d()@ transform functions also have the benefit of triggering hardware acceleration in Safari.  Dean Jackson, CSS 3D transform spec author and main WebKit dude, writes (by way of "Thomas Fuchs":http://mir.aculo.us/2010/08/05/html5-buzzwords-in-action/):

bq. In essence, any transform that has a 3D operation as one of its functions will trigger hardware compositing, even when the actual transform is 2D, or not doing anything at all (such as translate3d(0,0,0)). Note this is just current behaviour, and could change in the future (which is why we donâ€™t document or encourage it). But it is very helpful in some situations and can significantly improve redraw performance.

h2. Card flips

We now have all the tools to start making 3D objects. Let's get started with the basics, flipping a card. %%As mentioned above discussing the iPhone Weather app, using a card interface --do we need rationale here?--%%%

Here's the basic markup we'll need:

bc. <section class="container">
  <div class="card">
    <figure class="front">1</figure>
    <figure class="back">2</figure>
  </div>
</section>

So what do we have here. Obviously we need the faces of the card, both @front@ and @back@. The @card@ acts as a wrapper for the faces of the object. Finally the @container@ will house the 3D space. We're ready for some 3D stylez. Even for such a simple object, I recommend using this same patern for any 3D transform.  Keeping the 3D space element and the object element establishes a paradigm that is simple to understand and easier to style.

First, apply necessary @perspective@ to the parent 3D space, along with any size or positioning styles.

bc. .container { 
  width: 200px;
  height: 260px;
  -webkit-perspective: 800;
}

Now the @.card@ element can be transformed in 3D space, as its parent has @perspective@.  Let's add a CSS3 transition so users may see the transform take effect.

bc. .card {
  height: 100%; /* inherits the container height */
  -webkit-transform-style: preserve-3d;
  -webkit-transition: -webkit-transform 1s;
}

Details on @transform-style@ to come. With the transition in place, we need a corresponding style for the @.card@ for when it is flipped.

bc. .card.flipped {
  -webkit-transform: rotateY( 180deg );
}

To position the faces in 3D space, we'll need to reset their positions in 2D with @position: absolute@. In order to hide the back-side of the faces when they are faced away from the viewer, we use @backface-visibility: hidden@. 

bc. .card figure {
  display: block;
  height: 100%;
  width: 100%;
  position: absolute;
  -webkit-backface-visibility: hidden;
}

To flip the back around, we add a basic 3d transform of @rotateY( 180deg )@. 

bc. .card .front {
  background: red;
}
.card .back {
  background: blue;
  -webkit-transform: rotateY( 180deg );
}

As this is a 3D transform, this element requires to exist in 3D space. The @.container@'s @perspective@ only applies to direct descendant children, in this case @.card@. In order for children to inherit a parent's perspective, and live in the same 3D space, the parent needs to have @transform-style: preserve-3d@. Without 3D @transform-style@, these faces would be flattened and the back card's rotation would be nullified.

Now we have a working 3D object. To flip the card, we can toggle the @flipped@ class. When @flipped@, the @.card@ will rotate 180 degress, thus exposing the @.back@ face.

h3. 


`transforming for returning to 0 on the z axis`

`transform-origin`

`transition end events`





Looking at this %demo%, note that no matter how small the perspective value is, or where ever the transform origin is, the 1 panel always returns to its original position, as if it were not a part of a rotating 3D cube. 

